# time

Package time provides functionality for measuring and displaying time.

The calendrical calculations always assume a Gregorian calendar, with no leap
seconds.

### Monotonic Clocks

Operating systems provide both a “wall clock,” which is subject to changes
for clock synchronization, and a “monotonic clock,” which is not. The general
rule is that the wall clock is for telling time and the monotonic clock is for
measuring time. Rather than split the API, in this package the Time returned by
time.now contains both a wall clock reading and a monotonic clock reading; later
time-telling operations use the wall clock reading, but later time-measuring
operations, specifically comparisons and subtractions, use the monotonic clock
reading.

For example, this code always computes a positive elapsed time of approximately
20 milliseconds, even if the wall clock is changed during the operation being
timed:

```javascript
var start = time.now()
... operation that takes 20 milliseconds ...
var t = time.now()
var elapsed = t.sub(start);
```

Other idioms, such as time.since(start), time.until(deadline), and
time.now().before(deadline), are similarly robust against wall clock resets.

The rest of this section gives the precise details of how operations use
monotonic clocks, but understanding those details is not required to use this
package.

The Time returned by time.now contains a monotonic clock reading. If Time t has
a monotonic clock reading, `t.add` adds the same duration to both the wall clock
and monotonic clock readings to compute the result. Because t.addDate(y, m, d),
t.round(d), and t.truncate(d) are wall time computations, they always strip
any monotonic clock reading from their results. Because `t.in`, `t.local`, and
`t.utc` are used for their effect on the interpretation of the wall time, they
also strip any monotonic clock reading from their results. The canonical way to
strip a monotonic clock reading is to use `t = t.round(0)`.

If Times t and u both contain monotonic clock readings, the operations
t.after(u), t.before(u), t.equal(u), and t.sub(u) are carried out using the
monotonic clock readings alone, ignoring the wall clock readings. If either t or
u contains no monotonic clock reading, these operations fall back to using the
wall clock readings.

Because the monotonic clock reading has no meaning outside the current
process, the serialized forms generated by t.gobEncode, t.marshalBinary,
t.toJSON, and t.marshalText omit the monotonic clock reading, and t.format
provides no format for it. Similarly, the constructors time.date, time.parse,
time.parseInLocation, and time.unix, as well as the unmarshalers t.gobDecode,
t.unmarshalBinary. t.unmarshalJSON, and t.unmarshalText always create times with
no monotonic clock reading.

Note that the == operator is more or less useless. See the documentation for the
Time type for a discussion of equality testing for Time values.

For debugging, the result of t.string does include the monotonic clock reading
if present. If `t != u` because of different monotonic clock readings, that
difference will be visible when printing t.string() and u.string().

### Constants

These are predefined layouts for use in Time.Format and Time.Parse. The
reference time used in the layouts is the specific time:

    Mon Jan 2 15:04:05 MST 2006

which is Unix time 1136239445. Since MST is GMT-0700, the reference time can be thought of as

    01/02 03:04:05PM '06 -0700

To define your own format, write down what the reference time would look like
formatted your way; see the values of constants like ANSIC, StampMicro or
Kitchen for examples. The model is to demonstrate what the reference time looks
like so that the Format and Parse methods can apply the same transformation to a
general time value.

Within the format string, an underscore \_ represents a space that may be
replaced by a digit if the following number (a day) has two digits; for
compatibility with fixed-width Unix time formats.

A decimal point followed by one or more zeros represents a fractional second,
printed to the given number of decimal places. A decimal point followed by one
or more nines represents a fractional second, printed to the given number of
decimal places, with trailing zeros removed. When parsing (only), the input may
contain a fractional second field immediately after the seconds field, even if
the layout does not signify its presence. In that case a decimal point followed
by a maximal series of digits is parsed as a fractional second.

Numeric time zone offsets format as follows:

    -0700  ±hhmm
    -07:00 ±hh:mm
    -07    ±hh

Replacing the sign in the format with a Z triggers the ISO 8601 behavior of
printing Z instead of an offset for the UTC zone. Thus:

    Z0700  Z or ±hhmm
    Z07:00 Z or ±hh:mm
    Z07    Z or ±hh

The recognized day of week formats are "Mon" and "Monday". The recognized month
formats are "Jan" and "January".

Text in the format string that is not recognized as part of the reference time
is echoed verbatim during Format and expected to appear verbatim in the input to
Parse.

The executable example for time.Format demonstrates the working of the layout
string in detail and is a good reference.

Note that the RFC822, RFC850, and RFC1123 formats should be applied only
to local times. Applying them to UTC times will use "UTC" as the time zone
abbreviation, while strictly speaking those RFCs require the use of "GMT" in
that case. In general RFC1123Z should be used instead of RFC1123 for servers
that insist on that format, and RFC3339 should be preferred for new protocols.
RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with
time.Parse they do not accept all the time formats permitted by the RFCs. The
RFC3339Nano format removes trailing zeros from the seconds field and thus may
not sort correctly once formatted.

    time.ANSIC       = "Mon Jan _2 15:04:05 2006"
    time.UnixDate    = "Mon Jan _2 15:04:05 MST 2006"
    time.RubyDate    = "Mon Jan 02 15:04:05 -0700 2006"
    time.RFC822      = "02 Jan 06 15:04 MST"
    time.RFC822Z     = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
    time.RFC850      = "Monday, 02-Jan-06 15:04:05 MST"
    time.RFC1123     = "Mon, 02 Jan 2006 15:04:05 MST"
    time.RFC1123Z    = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
    time.RFC3339     = "2006-01-02T15:04:05Z07:00"
    time.RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"
    time.Kitchen     = "3:04PM"
    // Handy time stamps.
    time.Stamp      = "Jan _2 15:04:05"
    time.StampMilli = "Jan _2 15:04:05.000"
    time.StampMicro = "Jan _2 15:04:05.000000"
    time.StampNano  = "Jan _2 15:04:05.000000000"

### Duration constants

Common durations. There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.

To count the number of units in a Duration, divide:

```javascript
var second = time.Second
console.log(second.div(time.Millisecond).string())
```

To convert an integer number of units to a Duration, multiply:

    var seconds = 10;
    console.log(new time.Duration(seconds).mul(time.Second))

```javascript
    Nanosecond           = new time.Duration(1)
    Microsecond          = Nanosecond.muln(1000)
    Millisecond          = Microsecond.muln(1000)
    Second               = Millisecond.muln(1000)
    Minute               = Second.muln(60)
    Hour                 = Minute.muln(60)
```

Months are 1-indexed and constants exist for comparison.

    January    = new Month(1);
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December

## API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### ltn

Returns true if num is less than the duration. Num should be an integer.

**Parameters**

-   `num`  

### lten

Returns true if num is less than or equal to the duration. Num should be an
integer.

**Parameters**

-   `num`  

### toString

String returns a string representing the duration in the form "72h3m0.5s".
Leading zero units are omitted. As a special case, durations less than one
second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
that the leading digit is non-zero. The zero duration formats as 0s.

### truncate

Truncate returns the result of rounding d toward zero to a multiple of m.
If m &lt;= 0, Truncate returns d unchanged.

**Parameters**

-   `m`  

### absDate

absDate is like date but operates on an absolute time. yday === day of year
returns [year, Month, day, yday];

**Parameters**

-   `abs`  
-   `full`  

### unix

Unix returns the local Time corresponding to the given Unix time,
sec seconds and nsec nanoseconds since January 1, 1970 UTC.
It is valid to pass nsec outside the range [0, 999999999].
Not all sec values have a corresponding time value. One such
value is 1&lt;&lt;63-1 (the largest int64 value).

**Parameters**

-   `sec` **Int64** Integer number of seconds
-   `nsec` **Int64** Integer number of nanoseconds.

### Stamp

Handy time stamps.

### sleep

sleep(dur time.Duration, cb function())

Sleep calls cb after at least the duration d. A negative or zero duration
causes Sleep to return immediately.

**Parameters**

-   `dur`  
-   `cb`  

### parseInLocation

ParseInLocation is like Parse but differs in two important ways.
First, in the absence of time zone information, Parse interprets a time as UTC;
ParseInLocation interprets the time as in the given location.
Second, when given a zone offset or abbreviation, Parse tries to match it
against the Local location; ParseInLocation uses the given location.

**Parameters**

-   `layout`  
-   `value`  
-   `loc`  

### parseDuration

ParseDuration parses a duration string.
A duration string is a possibly signed sequence of
decimal numbers, each with optional fraction and a unit suffix,
such as "300ms", "-1.5h" or "2h45m".
Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".

**Parameters**

-   `s`  

### overflow

It's possible for overflow to give a positive number, so take care.

### match

match reports whether s1 and s2 match ignoring case.
It is assumed s1 and s2 are the same length.

**Parameters**

-   `s1`  
-   `s2`  

### Month

A Month specifies a month of the year (January = 1, ...). Compare Month
objects using a.month === b.month or a.equal(b);

**Parameters**

-   `i`  
-   `m` **integer** Month (1-indexed month)

#### equal

Equal returns true if the current month and b are equal.

**Parameters**

-   `b` **integer** Month Month object.

#### toString

toString returns a string for the given Month ("February")

### add

Add returns the time t+d.

**Parameters**

-   `d`  

### sub

Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
value that can be stored in a Duration, the maximum (or minimum) duration
will be returned.
To compute t-d for a duration d, use t.Add(-d).

**Parameters**

-   `u`  

### addDate

AddDate returns the time corresponding to adding the
given number of years, months, and days to t.
For example, AddDate(-1, 2, 3) applied to January 1, 2011
returns March 4, 2010.

AddDate normalizes its result in the same way that Date does,
so, for example, adding one month to October 31 yields
December 1, the normalized form for November 31.

**Parameters**

-   `years`  
-   `months`  
-   `days`  

### after

After reports whether the time instant t is after u.

**Parameters**

-   `u`  

### before

Before reports whether the time instant t is before u.

**Parameters**

-   `u`  

### equal

Equal reports whether t and u represent the same time instant.
Two times can be equal even if they are in different locations.
For example, 6:00 +0200 CEST and 4:00 UTC are Equal.
See the documentation on the Time type for the pitfalls of using == with
Time values; most code should use Equal instead.

**Parameters**

-   `u`  

### format

Format returns a textual representation of the time value formatted
according to layout, which defines the format by showing how the reference
time, defined to be
Mon Jan 2 15:04:05 -0700 MST 2006
would be displayed if it were the value; it serves as an example of the
desired output. The same display rules will then be applied to the time
value.

A fractional second is represented by adding a period and zeros
to the end of the seconds section of layout string, as in "15:04:05.000"
to format a time stamp with millisecond precision.

Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard
and convenient representations of the reference time. For more information
about the formats and the definition of the reference time, see the
documentation for ANSIC and the other constants defined by this package.

**Parameters**

-   `layout`  

### appendFormat

AppendFormat is like Format but appends the textual
representation to buf and returns the extended buffer.

Returns a bytes.Slice instance.

**Parameters**

-   `buf`  
-   `layout`  

### clock

Clock() {hour int, min int, sec int}

Clock returns the {hour, min, and sec} within the day specified by t.

### date

Date() {year int, month Month, day int}

Date returns the {year, month, and day} in which t occurs, as integers.

### location

Location returns the time zone information associated with t.

### nanosecond

Nanosecond returns the nanosecond offset within the second specified by t,
in the range [0, 999999999].

### second

Second returns the second offset within the minute specified by t, in the range [0, 59].

### minute

Minute returns the minute offset within the hour specified by t, in the range [0, 59].

### hour

Hour returns the hour within the day specified by t, in the range [0, 23].

### weekday

Weekday returns the day of the week specified by t.

### isoWeek

ISOWeek returns the ISO 8601 year and week number in which t occurs.
Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
of year n+1.

### yearDay

YearDay returns the day of the year specified by t, in the range [1,365]
for non-leap years, and [1,366] in leap years.

### isZero

IsZero reports whether t represents the zero time instant,
January 1, year 1, 00:00:00 UTC.

### unix

Unix returns t as a Unix time, the number of seconds elapsed since January
1, 1970 UTC.

### toJSON

MarshalJSON implements the json.Marshaler interface.
The time is a quoted string in RFC 3339 format, with sub-second precision added if present.

### zone

Zone() {name string, offset int}

Zone computes the time zone in effect at time t, returning the abbreviated
name of the zone (such as "CET") and its offset in seconds east of UTC.

### hr

Noon is 12PM, midnight is 12AM.

### hr

Noon is 12PM, midnight is 12AM.

### week

Calculate week as number of Mondays in year up to
and including today, plus 1 because the first week is week 0.
Putting the + 1 inside the numerator as a + 7 keeps the
numerator from being negative, which would cause it to
round incorrectly.

### week

If the week number is still 0, we're in early January but in
the last week of last year.

### week

A year has 53 weeks when Jan 1 or Dec 31 is a Thursday,
meaning Jan 1 of the next year is a Friday
or it was a leap year and Jan 1 of the next year is a Saturday.

### week

December 29 to 31 are in week 1 of next year if
they are after the last Thursday of the year and
December 31 is a Monday, Tuesday, or Wednesday.

### jan1wday

The week number is now correct under the assumption
that the first Monday of the year is in week 1.
If Jan 1 is a Tuesday, Wednesday, or Thursday, the first Monday
is actually in week 2.

### sec

Avoid function call if we hit the local time cache.

### \_date

Date returns the Time corresponding to
yyyy-mm-dd hh:mm:ss + nsec nanoseconds
in the appropriate zone for that time in the given location.

The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.

A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice. In such cases, the
choice of time zone, and therefore the time, is not well-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.

Date throws an error if loc is nil.
year int, month Month, day, hour, min, sec, nsec int, loc \*Location

**Parameters**

-   `year`  
-   `month`  
-   `day`  
-   `hour`  
-   `min`  
-   `sec`  
-   `nsec`  
-   `loc`  

### Duration

A Duration represents the elapsed time between two instants
as an int64 nanosecond count. The representation limits the
largest representable duration to approximately 290 years.

**Examples**

```javascript
var t0 = time.now();
expensiveCall();
var t1 = time.now();
console.log("The call took ", t1.sub(t0).toString(), "to run.");
```

### Time

A Time represents an instant in time with nanosecond precision.

Time instants can be compared using the before, after, and equal methods.
The sub method subtracts two instants, producing a Duration.
The add method adds a Time and a Duration, producing a Time.

The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
As this time is unlikely to come up in practice, the isZero method gives
a simple way of detecting a time that has not been initialized explicitly.

Each Time has associated with it a Location, consulted when computing the
presentation form of the time, such as in the Format, Hour, and Year methods.
The methods local, utc, and in return a Time with a specific location.
Changing the location in this way changes only the presentation; it does not
change the instant in time being denoted and therefore does not affect the
computations described in earlier paragraphs.

Therefore, Time values should not be used as map or database keys without
first guaranteeing that the identical Location has been set for all values,
which can be achieved through use of the UTC or Local method, and that the
monotonic clock reading has been stripped by setting t = t.round(0). In
general, prefer t.equal(u) to t == u, since t.equal uses the most accurate
comparison available and correctly handles the case when only one of its
arguments has a monotonic clock reading.

In addition to the required “wall clock” reading, a Time may contain an
optional reading of the current process's monotonic clock, to provide
additional precision for comparison or subtraction. See the “Monotonic
Clocks” section in the package documentation for details.

### Location

A Location maps time instants to the zone in use at that time. Typically,
the Location represents the collection of time offsets in use in a
geographical area, such as CEST and CET for central Europe.

### UTC

UTC represents Universal Coordinated Time (UTC).

### Local

Local represents the system's local time zone.

### Stamp

Handy time stamps.

### date

date(year int, month Month, day, hour, min, sec, nsec int, loc Location) Time

Date returns the Time corresponding to
yyyy-mm-dd hh:mm:ss + nsec nanoseconds
in the appropriate zone for that time in the given location.

The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.

A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice. In such cases, the
choice of time zone, and therefore the time, is not well-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.

Date throws an error if loc is nil.

**Parameters**

-   `year` **integer** 
-   `month` **[Month](#month)** 
-   `day` **integer** 
-   `hour` **integer** 
-   `min` **integer** 
-   `sec` **integer** 
-   `nsec` **integer** 
-   `loc` **[Location](https://developer.mozilla.org/en-US/docs/Web/API/Location)** 

**Examples**

```javascript
var t := time.date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
console.log("Go launched at", t.local())
```

Returns **Time** 

### fixedZone

fixedZone(name string, offset int)

FixedZone returns a Location that always uses the given zone name and
offset (seconds east of UTC).

**Parameters**

-   `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** The name of the time zone.
-   `offset` **integer** The offset in seconds east of UTC.

Returns **[Location](https://developer.mozilla.org/en-US/docs/Web/API/Location)** 

### loadLocation

loadLocation(name string)

LoadLocation synchronously returns the Location with the given name.

If the name is "" or "UTC", LoadLocation returns UTC.
If the name is "Local", LoadLocation returns Local.

Otherwise, the name is taken to be a location name corresponding to a file
in the IANA Time Zone database, such as "America/New_York".

The time zone database needed by LoadLocation may not be
present on all systems, especially non-Unix systems.
LoadLocation looks in the directory or uncompressed zip file
named by the ZONEINFO environment variable, if any, then looks in
known installation locations on Unix systems,
and finally looks in internal/time/zoneinfo.zip.

loadLocation throws an error if the location could not be found.

**Parameters**

-   `name` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** The name of the location to load.

Returns **[Location](https://developer.mozilla.org/en-US/docs/Web/API/Location)** 

### now

Now returns the current local time.

Returns **Time** 

### parse

Parse parses a formatted string and returns the time value it represents.
The layout defines the format by showing how the reference time,
defined to be

     Mon Jan 2 15:04:05 -0700 MST 2006

would be interpreted if it were the value; it serves as an example of
the input format. The same interpretation will then be made to the
input string.

Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard
and convenient representations of the reference time. For more information
about the formats and the definition of the reference time, see the
documentation for ANSIC and the other constants defined by this package.
Also, the executable example for time.Format demonstrates the working
of the layout string in detail and is a good reference.

Elements omitted from the value are assumed to be zero or, when
zero is impossible, one, so parsing "3:04pm" returns the time
corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
0, this time is before the zero Time).
Years must be in the range 0000..9999. The day of the week is checked
for syntax but it is otherwise ignored.

In the absence of a time zone indicator, Parse returns a time in UTC.

When parsing a time with a zone offset like -0700, if the offset corresponds
to a time zone used by the current location (Local), then Parse uses that
location and zone in the returned time. Otherwise it records the time as
being in a fabricated location with time fixed at the given zone offset.

When parsing a time with a zone abbreviation like MST, if the zone abbreviation
has a defined offset in the current location, then that offset is used.
The zone abbreviation "UTC" is recognized as UTC regardless of location.
If the zone abbreviation is unknown, Parse records the time as being
in a fabricated location with the given zone abbreviation and a zero offset.
This choice means that such a time can be parsed and reformatted with the
same layout losslessly, but the exact instant used in the representation will
differ by the actual zone offset. To avoid such problems, prefer time layouts
that use a numeric zone offset, or use ParseInLocation.

parse throws an error if the input could not be parsed as a time.

**Parameters**

-   `layout` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** The layout
-   `value` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Value to parse using the layout
-   `loc` **[Location](https://developer.mozilla.org/en-US/docs/Web/API/Location)** Location to parse the value in.

**Examples**

```javascript
// See the example for time.Format for a thorough description of how
// to define the layout string to parse a time.Time value; Parse and
// Format use the same model to describe their input and output.

// longForm shows by example how the reference time would be represented in
// the desired layout.
const longForm = "Jan 2, 2006 at 3:04pm (MST)";
var t = time.parse(longForm, "Feb 3, 2013 at 7:54pm (PST)");
console.log(t);

// shortForm is another way the reference time would be represented
// in the desired layout; it has no time zone present.
// Note: without explicit zone, returns time in UTC.
const shortForm = "2006-Jan-02";
t = time.parse(shortForm, "2013-Feb-03");
console.log(t.toString());
```

Returns **Time** 

### parseInLocation

parseInLocation is like parse but differs in two important ways.
First, in the absence of time zone information, Parse interprets a time as UTC;
ParseInLocation interprets the time as in the given location.
Second, when given a zone offset or abbreviation, Parse tries to match it
against the Local location; ParseInLocation uses the given location.

**Parameters**

-   `layout` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** The layout
-   `value` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Value to parse using the layout
-   `loc` **[Location](https://developer.mozilla.org/en-US/docs/Web/API/Location)** Location to parse the value in.

**Examples**

```javascript
var loc = time.loadLocation("Europe/Berlin")

const longForm = "Jan 2, 2006 at 3:04pm (MST)"
var t = time.parseInLocation(longForm, "Jul 9, 2012 at 5:02am (CEST)", loc)
console.log(t)

// Note: without explicit zone, returns time in given location.
const shortForm = "2006-Jan-02"
t, _ = time.parseInLocation(shortForm, "2012-Jul-09", loc)
console.log(t)
```

Returns **Time** 

### parseDuration

parseDuration(string) time.Duration

ParseDuration parses a duration string.
A duration string is a possibly signed sequence of
decimal numbers, each with optional fraction and a unit suffix,
such as "300ms", "-1.5h" or "2h45m".
Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".

parseDuration throws an error if the input could not be parsed as
a duration.

**Parameters**

-   `s` **[string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)** Duration to parse

Returns **Duration** 

### sleep

sleep(dur time.Duration, cb function())

Sleep calls cb after at least the duration d. A negative or zero duration
causes Sleep to return immediately.

**Parameters**

-   `dur` **Duration** Amount of time to sleep for
-   `Callback` **[function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)** to hit after we have slept for that time

### unix

Unix returns the local Time corresponding to the given Unix time,
sec seconds and nsec nanoseconds since January 1, 1970 UTC.
It is valid to pass nsec outside the range [0, 999999999].
Not all sec values have a corresponding time value. One such
value is 1&lt;&lt;63-1 (the largest int64 value).

**Parameters**

-   `sec` **internal.Int64** Seconds since the epoch
-   `nsec` **internal.Int64** Nanoseconds since the epoch

Returns **time.Time** 
